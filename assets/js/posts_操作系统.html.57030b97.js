"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2587],{6262:(o,e)=>{e.A=(o,e)=>{const t=o.__vccOpts||o;for(const[o,n]of e)t[o]=n;return t}},2800:(o,e,t)=>{t.r(e),t.d(e,{comp:()=>i,data:()=>s});var n=t(641);const r=[(0,n.Fv)('<h1 id="juc前置操作系统知识" tabindex="-1"><a class="header-anchor" href="#juc前置操作系统知识"><span>JUC前置操作系统知识</span></a></h1><ol><li><strong>进程与线程</strong>: <ul><li><strong>操作系统知识</strong>: 操作系统如何管理进程和线程，线程调度的基本策略（如时间片轮转、优先级调度等），以及上下文切换的概念。</li><li><strong>JUC对应</strong>: Java中的多线程编程，<code>Thread</code>类的使用，线程的生命周期，以及<code>ExecutorService</code>框架。</li></ul></li><li><strong>同步与互斥</strong>: <ul><li><strong>操作系统知识</strong>: 临界区的概念，互斥锁（mutex）的工作原理，以及死锁的产生条件和预防措施。</li><li><strong>JUC对应</strong>: <code>synchronized</code>关键字，<code>ReentrantLock</code>类，以及<code>Condition</code>接口用于更细粒度的线程间通信。</li></ul></li><li><strong>内存模型</strong>: <ul><li><strong>操作系统知识</strong>: 内存层次结构，缓存一致性，以及主内存与处理器缓存之间的数据同步问题。</li><li><strong>JUC对应</strong>: Java内存模型（JMM），<code>volatile</code>关键字的作用，以及<code>Atomic</code>类族提供的原子操作。</li></ul></li><li><strong>锁的粒度</strong>: <ul><li><strong>操作系统知识</strong>: 锁的粒度选择（粗粒度锁vs细粒度锁）对性能的影响。</li><li><strong>JUC对应</strong>: 选择适当的锁策略，如使用<code>ReadWriteLock</code>实现读写分离，或者使用<code>ConcurrentHashMap</code>等数据结构提供的更细粒度的锁。</li></ul></li><li><strong>线程局部存储（TLS）</strong>: <ul><li><strong>操作系统知识</strong>: TLS用于在线程之间隔离数据，避免全局变量的争用。</li><li><strong>JUC对应</strong>: Java中的<code>ThreadLocal</code>类，用于实现线程内部的数据隔离，减少锁的竞争。</li></ul></li><li><strong>内存屏障</strong>: <ul><li><strong>操作系统知识</strong>: 编译器和处理器的重排序规则，以及内存屏障指令如何强制执行特定的内存访问顺序。</li><li><strong>JUC对应</strong>: Java内存模型中的内存屏障，如<code>happens-before</code>原则，以及<code>volatile</code>变量和<code>Atomic</code>类中的内存屏障使用。</li></ul></li><li><strong>死锁检测与避免</strong>: <ul><li><strong>操作系统知识</strong>: 死锁的四个必要条件（互斥、占有并等待、非抢占和循环等待），以及检测和避免死锁的算法。</li><li><strong>JUC对应</strong>: 避免在Java程序中产生死锁，如使用<code>ThreadMXBean</code>的<code>findMonitorDeadlockedThreads()</code>方法检查死锁，以及合理设计锁的获取和释放顺序</li></ul></li><li><strong>信号量与信号</strong>: <ul><li><strong>操作系统知识</strong>: 信号量用于资源管理和同步，而信号用于异步通知进程或线程。</li><li><strong>JUC对应</strong>: Java中的<code>Semaphore</code>类提供类似信号量的功能，用于限制并发访问共享资源的数量；而<code>Signal</code>类虽然在JUC中没有直接对应，但<code>AtomicStampedReference</code>可以用于实现类似信号的机制。</li></ul></li><li><strong>AQS（AbstractQueuedSynchronizer）</strong>: <ul><li><strong>操作系统知识</strong>: 对于操作系统如何处理等待队列和条件变量的理解。</li><li><strong>JUC对应</strong>: AQS是Java并发库中的基础组件，提供了构建锁和同步器的基础框架，理解其工作原理对于深入学习JUC非常重要。</li></ul></li><li><strong>非阻塞算法</strong>: <ul><li><strong>操作系统知识</strong>: 基于比较和交换（CAS）指令的非阻塞同步算法，以及它们如何避免了传统锁的上下文切换和等待成本。</li><li><strong>JUC对应</strong>: Java中的<code>Atomic</code>类族提供了基于CAS的原子操作，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，用于实现无锁的并发控制。</li></ul></li><li><strong>高级锁机制</strong>: <ul><li><strong>操作系统知识</strong>: 先进的锁类型，如自旋锁（Spinlock）、读写锁（Read-Write Lock）、偏向锁（Biased Lock）和轻量级锁（Lightweight Lock）。</li><li><strong>JUC对应</strong>: Java中的锁升级机制，如在<code>java.util.concurrent.locks</code>包中<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>的实现细节，以及JVM在对象头中实现的锁优化技术。</li></ul></li><li><strong>并发数据结构</strong>: <ul><li><strong>操作系统知识</strong>: 并发数据结构的设计和实现，如无锁队列、栈和哈希表。</li><li><strong>JUC对应</strong>: Java并发库中的<code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>、<code>ConcurrentLinkedDeque</code>等，以及它们如何利用CAS操作实现线程安全。</li></ul></li><li><strong>异步I/O</strong>: <ul><li><strong>操作系统知识</strong>: 异步I/O模型，如完成端口（Completion Port）、异步I/O（AIO）和事件驱动I/O（EIO）。</li><li><strong>JUC对应</strong>: Java NIO 2中引入的<code>AsynchronousFileChannel</code>和<code>AsynchronousSocketChannel</code>等类，用于实现非阻塞的I/O操作。</li></ul></li><li><strong>CPU调度</strong>: <ul><li><strong>操作系统知识</strong>: CPU调度算法，如先来先服务(FCFS)、最短作业优先(SJF)、优先级调度和多级反馈队列(Multilevel Feedback Queue)等。</li><li><strong>JUC对应</strong>: 理解线程优先级的设置和影响，以及如何使用<code>Executor</code>框架中的<code>ThreadPoolExecutor</code>自定义线程池参数，比如核心线程数和最大线程数，以优化线程调度。</li></ul></li></ol>',2)],l={},i=(0,t(6262).A)(l,[["render",function(o,e){return(0,n.uX)(),(0,n.CE)("div",null,r)}]]),s=JSON.parse('{"path":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html","title":"JUC前置操作系统知识","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-08-26T00:00:00.000Z","category":["计算机"],"tag":["操作系统","JUC"],"star":true,"sticky":true,"description":"JUC前置操作系统知识 进程与线程: 操作系统知识: 操作系统如何管理进程和线程，线程调度的基本策略（如时间片轮转、优先级调度等），以及上下文切换的概念。 JUC对应: Java中的多线程编程，Thread类的使用，线程的生命周期，以及ExecutorService框架。 同步与互斥: 操作系统知识: 临界区的概念，互斥锁（mutex）的工作原理，以及...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"王坤峰的博客"}],["meta",{"property":"og:title","content":"JUC前置操作系统知识"}],["meta",{"property":"og:description","content":"JUC前置操作系统知识 进程与线程: 操作系统知识: 操作系统如何管理进程和线程，线程调度的基本策略（如时间片轮转、优先级调度等），以及上下文切换的概念。 JUC对应: Java中的多线程编程，Thread类的使用，线程的生命周期，以及ExecutorService框架。 同步与互斥: 操作系统知识: 临界区的概念，互斥锁（mutex）的工作原理，以及..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/blog/assets/images/cover2.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-26T01:29:08.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/blog/assets/images/cover2.jpg"}],["meta",{"name":"twitter:image:alt","content":"JUC前置操作系统知识"}],["meta",{"property":"article:author","content":"王坤峰"}],["meta",{"property":"article:tag","content":"操作系统"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:published_time","content":"2024-08-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-26T01:29:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC前置操作系统知识\\",\\"image\\":[\\"https://mister-hope.github.io/blog/assets/images/cover2.jpg\\"],\\"datePublished\\":\\"2024-08-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-26T01:29:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"王坤峰\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1724635748000,"updatedTime":1724635748000,"contributors":[{"name":"“王坤峰”","email":"kunfeng_wangcs@163.com","commits":1}]},"readingTime":{"minutes":3.78,"words":1135},"filePathRelative":"posts/操作系统.md","localizedDate":"2024年8月26日","excerpt":"\\n<ol>\\n<li><strong>进程与线程</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 操作系统如何管理进程和线程，线程调度的基本策略（如时间片轮转、优先级调度等），以及上下文切换的概念。</li>\\n<li><strong>JUC对应</strong>: Java中的多线程编程，<code>Thread</code>类的使用，线程的生命周期，以及<code>ExecutorService</code>框架。</li>\\n</ul>\\n</li>\\n<li><strong>同步与互斥</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 临界区的概念，互斥锁（mutex）的工作原理，以及死锁的产生条件和预防措施。</li>\\n<li><strong>JUC对应</strong>: <code>synchronized</code>关键字，<code>ReentrantLock</code>类，以及<code>Condition</code>接口用于更细粒度的线程间通信。</li>\\n</ul>\\n</li>\\n<li><strong>内存模型</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 内存层次结构，缓存一致性，以及主内存与处理器缓存之间的数据同步问题。</li>\\n<li><strong>JUC对应</strong>: Java内存模型（JMM），<code>volatile</code>关键字的作用，以及<code>Atomic</code>类族提供的原子操作。</li>\\n</ul>\\n</li>\\n<li><strong>锁的粒度</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 锁的粒度选择（粗粒度锁vs细粒度锁）对性能的影响。</li>\\n<li><strong>JUC对应</strong>: 选择适当的锁策略，如使用<code>ReadWriteLock</code>实现读写分离，或者使用<code>ConcurrentHashMap</code>等数据结构提供的更细粒度的锁。</li>\\n</ul>\\n</li>\\n<li><strong>线程局部存储（TLS）</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: TLS用于在线程之间隔离数据，避免全局变量的争用。</li>\\n<li><strong>JUC对应</strong>: Java中的<code>ThreadLocal</code>类，用于实现线程内部的数据隔离，减少锁的竞争。</li>\\n</ul>\\n</li>\\n<li><strong>内存屏障</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 编译器和处理器的重排序规则，以及内存屏障指令如何强制执行特定的内存访问顺序。</li>\\n<li><strong>JUC对应</strong>: Java内存模型中的内存屏障，如<code>happens-before</code>原则，以及<code>volatile</code>变量和<code>Atomic</code>类中的内存屏障使用。</li>\\n</ul>\\n</li>\\n<li><strong>死锁检测与避免</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 死锁的四个必要条件（互斥、占有并等待、非抢占和循环等待），以及检测和避免死锁的算法。</li>\\n<li><strong>JUC对应</strong>: 避免在Java程序中产生死锁，如使用<code>ThreadMXBean</code>的<code>findMonitorDeadlockedThreads()</code>方法检查死锁，以及合理设计锁的获取和释放顺序</li>\\n</ul>\\n</li>\\n<li><strong>信号量与信号</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 信号量用于资源管理和同步，而信号用于异步通知进程或线程。</li>\\n<li><strong>JUC对应</strong>: Java中的<code>Semaphore</code>类提供类似信号量的功能，用于限制并发访问共享资源的数量；而<code>Signal</code>类虽然在JUC中没有直接对应，但<code>AtomicStampedReference</code>可以用于实现类似信号的机制。</li>\\n</ul>\\n</li>\\n<li><strong>AQS（AbstractQueuedSynchronizer）</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 对于操作系统如何处理等待队列和条件变量的理解。</li>\\n<li><strong>JUC对应</strong>: AQS是Java并发库中的基础组件，提供了构建锁和同步器的基础框架，理解其工作原理对于深入学习JUC非常重要。</li>\\n</ul>\\n</li>\\n<li><strong>非阻塞算法</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 基于比较和交换（CAS）指令的非阻塞同步算法，以及它们如何避免了传统锁的上下文切换和等待成本。</li>\\n<li><strong>JUC对应</strong>: Java中的<code>Atomic</code>类族提供了基于CAS的原子操作，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，用于实现无锁的并发控制。</li>\\n</ul>\\n</li>\\n<li><strong>高级锁机制</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 先进的锁类型，如自旋锁（Spinlock）、读写锁（Read-Write Lock）、偏向锁（Biased Lock）和轻量级锁（Lightweight Lock）。</li>\\n<li><strong>JUC对应</strong>: Java中的锁升级机制，如在<code>java.util.concurrent.locks</code>包中<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>的实现细节，以及JVM在对象头中实现的锁优化技术。</li>\\n</ul>\\n</li>\\n<li><strong>并发数据结构</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 并发数据结构的设计和实现，如无锁队列、栈和哈希表。</li>\\n<li><strong>JUC对应</strong>: Java并发库中的<code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>、<code>ConcurrentLinkedDeque</code>等，以及它们如何利用CAS操作实现线程安全。</li>\\n</ul>\\n</li>\\n<li><strong>异步I/O</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: 异步I/O模型，如完成端口（Completion Port）、异步I/O（AIO）和事件驱动I/O（EIO）。</li>\\n<li><strong>JUC对应</strong>: Java NIO 2中引入的<code>AsynchronousFileChannel</code>和<code>AsynchronousSocketChannel</code>等类，用于实现非阻塞的I/O操作。</li>\\n</ul>\\n</li>\\n<li><strong>CPU调度</strong>:\\n<ul>\\n<li><strong>操作系统知识</strong>: CPU调度算法，如先来先服务(FCFS)、最短作业优先(SJF)、优先级调度和多级反馈队列(Multilevel Feedback Queue)等。</li>\\n<li><strong>JUC对应</strong>: 理解线程优先级的设置和影响，以及如何使用<code>Executor</code>框架中的<code>ThreadPoolExecutor</code>自定义线程池参数，比如核心线程数和最大线程数，以优化线程调度。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);